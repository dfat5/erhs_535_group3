---
title: "Final Presentation"
author: "Group 3"
date: "December 4, 2017"
output:
  beamer_presentation: default
  slidy_presentation: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r, include=FALSE}
library(readxl)
library(tidyverse)
library(ggplot2)
library(rpart)
library(randomForest)
library(ggthemes)
library(glmnet)
library(knitr)
source("../R/practice_data.R")
```

## Group 3 Objective: Association between dependent and independent variables

- Create summaries and visualizations of how the dependent variable is associated with different independent variables. Here, we will try to discover if there are characteristics of the drugs that are associated with effectiveness against TB. This group will need to come up with ways (and code) to analyze that in the data. This might include generalized linear models, scatterplots, and possibly other supervised learning methods. 


## Rationale: 

- Explain what you were hoping to achieve in writing the functions / app framework that your group created.


## Idea development: 

- Describe the different ideas your group explored. What were the biggest challenges in this stage? For any ideas that didn’t pan out, what were the key constraints? Also describe how you would tackle this problem if you were starting over.


## Key functions: 

- Describe the final functions / app framework you decided on. Explain why you picked these. For functions, include documentation for the functions:
- Write a brief title for the function (< 8 words) and a brief description
(3–4 sentences).
- Define all parameters. For example, if you have a df parameter,
explain that this is the dataframe that will be modeled / visualized. If
it must have certain column with certain names, specify that.
- Define what the functions will output (e.g., “A ggplot object showing
. . . ” or “The model output object from running a . . . ”).
- If you have a reference (e.g., for a model you’re fitting in the
function), you can include that
- If you want an extra challenge, try to use the Roxygen2 syntax in
writing these descriptions. Otherwise, you can write them in code
comments.


## Room for errors: 

- So far, we have focused on getting working prototypes, without making sure they’re error-proof and robust to a user doing something non-standard. Identify three things a user could do that could make your functions “break” (i.e., either return an error message or return something other than what you hope they will).


## Next steps: 

- Include a section where you describe what you think are interesting next steps, i.e., what you would pursue next if you were continuing work on this project. Lay out explicitly a few ideas (2–3) that you think would be helpful. Be sure, when relevant, to describe how feedback from the project researchers helped in forming these ideas for next steps.


## Functions:


## Visualize univariate variables in a scatterplot function, by drug dose

- To visualize univariate variables correlations with the outcome variables, a faceted scatterplot colored by dose was created. Inputs to this function include `peak_trough`, which evaluates the peak or trough (Cmax or Trough) respectively, of drug following injection. The dep_var options are either ELU or ESP (lung levels and spleen levels, respectively. 

```{r fig.height=4, fig.width=8, warnings = FALSE}
univar_plot <- function(peak_trough, dep_var, data = efficacy_summary) {
 
  function_data <- data %>% 
  filter(level == peak_trough) %>% 
  gather(key = independent_var, value = indep_measure, -drug, -dosage, -dose_int, -level, -ELU, -ESP, na.rm = TRUE) %>% 
  select(drug, dosage, dose_int, level, dep_var, indep_measure, independent_var) 
  
  if(dep_var=="ELU") {vect <- function_data$ELU}
  if(dep_var=="ESP") {vect <- function_data$ESP}
        
  scatter_plot <- function_data %>%
  ggplot(aes(x = indep_measure, y = vect, color = dose_int)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = lm, se = FALSE) +
  labs(x = "Independent variable", y = "Dependent Variable") +
  facet_wrap(~independent_var, scales = "free_x")

scatter_plot
}

```

## Scatterplot 
```{r, fig.height=5, fig.width=7}
test <- univar_plot(peak_trough = "Cmax", dep_var = "ELU")
test
```



## Interpretation

- It appears that the relationship between independent and dependent variables are dependent on dose for variables cLogP, huPPB, PLA, and SLE. The others are not dependent on dose. 
- Dose may be an important factor to consider when evaluating the relationship between independent and dependent variables. 



## Fitting Linear Models Function (Example inputs Peak_trough = Cmax, Dep_var = ELU)

- I fitted a linear model regressing dependent on independent variables to assess the relationships between them. Inputs to this function include peak_trough (options are Cmax or trough), or the dep_var (options are ELU or ESP). The units of scale for each variable were normalized so that we could compare across coeficients. 

```{r fig.height= 4, fig.width=8}
#Define the linear model function

linear_model <- function(peak_trough, dep_var, data = efficacy_summary) {
  
function_data <- data %>% 
  filter(level == peak_trough) %>% 
  gather(key = independent_var, value = indep_measure, -drug, -dosage, -dose_int, -level, -ELU, -ESP, na.rm = TRUE) %>% 
  select(drug, dosage, dose_int, level, dep_var, indep_measure, independent_var) 
  
  if(dep_var=="ELU") {function_data$vect <- function_data$ELU}
  if(dep_var=="ESP") {function_data$vect <- function_data$ESP}

  model_function <- function(data) {
    model_results <- lm(vect ~ scale(indep_measure), data = data)
  }
  
estimate_results <- function_data %>% 
  group_by(independent_var, dose_int) %>% 
  nest() %>% 
  mutate(mod_results = purrr::map(data, model_function)) %>% 
  mutate(mod_coefs = purrr::map(mod_results, broom::tidy)) %>% 
  select(independent_var, dose_int, mod_results, mod_coefs) %>% 
  unnest(mod_coefs) %>% 
  filter(term == "scale(indep_measure)")

coef_plot <- estimate_results %>%
  mutate(independent_var = forcats::fct_reorder(independent_var, estimate, fun = max)) %>%
  rename(Dose_Interval = dose_int) %>% 
  ggplot(aes(x = estimate, y = independent_var, color = Dose_Interval)) +
  geom_point(aes(size = 1 / std.error)) +
  scale_size_continuous(guide = FALSE) +
  theme_few() + 
  ggtitle(label = "Linear model coefficients as function of independent variables, \n by drug dose and model uncertainty", subtitle = "smaller points have more uncertainty than larger points") +
  geom_vline(xintercept = 0, color = "cornflower blue") 

coef_plot
}
```

## Coefficients Plot
```{r}
test_2 <- linear_model(peak_trough = "Cmax", dep_var = "ELU")
test_2
```




## Interpretation

-The coefficient plot generated by this function shows each independent variable on the y axis and the respective model coefficient on the x axis. If the coefficient is negative, for example, as it is with MacUptake, an interpretation would be for every unit of change in the MacUptake, the ELU will decrease by 0.5 Units. Therefore, MacUptake has a negative relationship with ELU, decreasing the ELU. The diameter of the point represents the level of certainty of the coeficient in this model.

## Regression Tree Function
```{r}
regression_tree <- function(dep_var, min_split, min_bucket, data = efficacy_summary) {
  
  if (dep_var == "ELU") {
    
  function_data <- data %>%
    filter(!is.na(ELU)) %>% 
    rename(plasma = PLA, `Uninvolved lung` = ULU,
         `Rim (of Lesion)` = RIM, `Outer Caseum` = OCS, `Inner Caseum` = ICS,
         `Standard Lung` = SLU, `Standard Lesion` = SLE, `Human Plasma Binding` = huPPB,
         `Mouse Plasma Binding` = muPPB, `MIC Erdman Strain` = MIC_Erdman,
         `MIC Erdman Strain with Serum` = MICserumErd, `MIC rv strain` = MIC_Rv,
         `Caseum binding` = Caseum_binding, `Macrophage Uptake (Ratio)` = MacUptake)
  
  tree <- rpart(ELU ~  drug + dosage + level + 
                 plasma + `Uninvolved lung` + `Rim (of Lesion)` + `Outer Caseum` + 
                 `Inner Caseum` + `Standard Lung` + `Standard Lesion` + 
                 cLogP + `Human Plasma Binding` + `Mouse Plasma Binding` + 
                 `MIC Erdman Strain` + `MIC Erdman Strain with Serum` + `MIC rv strain` + 
                 `Caseum binding` + `Macrophage Uptake (Ratio)`,
               data = function_data, 
               control = rpart.control(cp = -1, minsplit = min_split, 
                                       minbucket = min_bucket))
  }
  
  if (dep_var == "ESP") {
    
  function_data <- data %>%
    filter(!is.na(ESP)) %>% 
    rename(plasma = PLA, `Uninvolved lung` = ULU,
         `Rim (of Lesion)` = RIM, `Outer Caseum` = OCS, `Inner Caseum` = ICS,
         `Standard Lung` = SLU, `Standard Lesion` = SLE, `Human Plasma Binding` = huPPB,
         `Mouse Plasma Binding` = muPPB, `MIC Erdman Strain` = MIC_Erdman,
         `MIC Erdman Strain with Serum` = MICserumErd, `MIC rv strain` = MIC_Rv,
         `Caseum binding` = Caseum_binding, `Macrophage Uptake (Ratio)` = MacUptake)
  
  tree <- rpart(ESP ~  drug + dosage + level + 
                 plasma + `Uninvolved lung` + `Rim (of Lesion)` + `Outer Caseum` + 
                 `Inner Caseum` + `Standard Lung` + `Standard Lesion` + 
                 cLogP + `Human Plasma Binding` + `Mouse Plasma Binding` + 
                 `MIC Erdman Strain` + `MIC Erdman Strain with Serum` + `MIC rv strain` + 
                 `Caseum binding` + `Macrophage Uptake (Ratio)`,
               data = function_data, 
               control = rpart.control(cp = -1, minsplit = min_split, 
                                       minbucket = min_bucket))
  }
  
  par(mfrow = c(1,1.5), xpd = NA) # otherwise on some devices the text is clipped
  plot(tree, uniform=TRUE)
  text(tree, use.n=TRUE, all=TRUE, cex=.8, minlength = 0, fancy = TRUE, 
     bg = "lightblue", fwidth = .8, fheight = .8)
}
```

## Testing regression_tree function
```{r}
#dep_var options: "ELU" (lung efficacy) or "ESP" (spleen efficacy)
#min_split: numeric input indicating minimum # observations for a split to be attempted
#min_bucket: numeric input indicating minimum # observations in a terminal node
regression_tree(dep_var = "ELU", min_split = 8, min_bucket = 6)
```

## Interpretation

- The number at the top of each node is indicating the mean of the outcome variable for the observations in that node (mean of 1.5 for node 1). Below each node is indicating what each split was based on. Splits are chosen based on a complexity parameter. Starting from node 1, the first split is made so that it leads to the greatest possible reduction in RSS. Node 3 is a terminal node because it only has 4 observations, which was the minimum number of observations a node can have to be considered (set in our function parameters). Given the 16 observations in node 2, another split is made that again gives the greatest possible reduction in RSS. This process continues until either the min_split or the min_bucket parameters are fulfilled for each node from the preset function parameters.  


## LASSO Function

The function for LASSO required the following inputs:

- Dependant varaible 
- Dose
- Dataframe, though the dataframe default is efficacy_summary

The output in the end is coefficients with smaller coefficients being resitricted to zero.

```{r}
LASSO_model <- function(dep_var, dose, df = efficacy_summary) {
  data <- na.omit(df) %>% 
  select_if(is.numeric) %>%
  filter(dosage == dose)

response <- df %>% 
  select(dep_var)

predictors <- df %>%
  select(c("PLA", "ULU", "RIM", "OCS", "ICS", "SLU", "SLE", "cLogP", "huPPB", "muPPB", "MIC_Erdman", 'MICserumErd', "MIC_Rv", "Caseum_binding", "MacUptake"))

y <- as.numeric(unlist(response))
x <- as.matrix(predictors)

fit = glmnet(x, y)

coeff <- coef(fit,s=0.1)
coeff <- as.data.frame(as.matrix(coeff))

coeff <- coeff %>% 
  rownames_to_column() %>% 
  filter(coeff > 0) 
  colnames(coeff) <- c("predictor", "coeff")
coeff %>% 
  kable()
}
```

## Testing LASSO function:

```{r}
#LASSO_model(dep_var = "ELU", dose = 100)
```


## Interpretation: 

- This function outputs raw coefficents and an intercept on an penalized maximum likelihood model. Models dropped from the model are represented with zeros. It computes a LASSO penalty for small coefficents and drops them, resulting in only the coef with the most leverage remaining.  



## RandomForest Function

- The user specifies which dependent variable they would like to use (either ELU or ESP). The user can also specify a dataset they would like to use, if one is not provided then a default dataset is utilized. The function var_importance takes the input and outputs a graph displaying the which variables are the best predictors of the input (either ELU or ESP). 
```{r randomForest function}


best_variables <- function(dep_var, df = efficacy_summary){
  
  
  title <- paste0 ("Predicing Variable Importance Using ", as.character(dep_var))
  
  if(dep_var == "ELU"){
  dataset <- df %>% 
    select(-ESP) %>% 
    mutate(huPPB = as.numeric(huPPB), 
         muPPB = as.numeric(muPPB), 
         dosage = as.factor(dosage), 
         dose_int = as.factor(dose_int), 
         level = as.factor(level), 
         drug = as.factor(drug))

efficacy.rf <- randomForest( ELU~ ., data =dataset,
              na.action = na.roughfix,
                        ntree= 1000, 
                        importance = TRUE)
  }
  
  if (dep_var == "ESP"){
    dataset <- df %>% 
      select(-ELU) %>% 
    mutate(huPPB = as.numeric(huPPB), 
         muPPB = as.numeric(muPPB), 
         dosage = as.factor(dosage), 
         dose_int = as.factor(dose_int), 
         level = as.factor(level), 
         drug = as.factor(drug))

efficacy.rf <- randomForest( ESP ~ ., data =dataset,
              na.action = na.roughfix,
                        ntree= 1000, 
                        importance = TRUE)
  }
  
graph <-importance(efficacy.rf, type = 1) %>% 
  as.data.frame() %>% 
  rownames_to_column() %>% 
  rename(variable = rowname, 
         mse = `%IncMSE`) 



graph %>% 
  filter(mse > 0) %>% 
  ggplot()+
  geom_point(aes(x = mse, y = reorder(variable, mse)))+
  theme_minimal()+
  ggtitle(title)+
  labs(y = "Variable", 
       x = "Importance")
}
```

## Testing Random Forest

```{r testing function}
best_variables("ELU")
best_variables("ESP")
```

## Interpretation

- This function utilizes the function randomForest to predict which variables are the most important predictors of the associated outcome. This model works by randomly creating small data nodes that are split using the best predictor from a subset of predictors randomly chosen at each node. In order to determine variable importance, the algorithm looks at how much the predictive error increases as all variables remain unchanged while one is permuted. The resulting output shows the % increase in the mean standard error for each variable considered individually. The higher the number the more important the variable for model building. 
